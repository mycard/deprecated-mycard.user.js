// Generated by CoffeeScript 1.6.2
(function() {
  var $, Card, CardDeck, HTMLNode, HtmlContent, Leaf, Main, Tree, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Card = (function() {
    var card_types, categories, imageExt, imagePath, thumbImagePath, types, _attributes,
      _this = this;

    types = ['warrior', 'spellcaster', 'fairy', 'fiend', 'zombie', 'machine', 'aqua', 'pyro', 'rock', 'winged_beast', 'plant', 'insect', 'thunder', 'dragon', 'beast', 'beast_warrior', 'dinosaur', 'fish', 'sea_serpent', 'reptile', 'psychic', 'divine_beast', 'creator_god'];

    _attributes = ['earth', 'water', 'fire', 'wind', 'light', 'dark', 'divine'];

    categories = ['monster', 'spell', 'trap'];

    card_types = [null, null, null, null, 'normal', 'effect', 'fusion', 'ritual', null, 'spirit', 'union', 'gemini', 'tuner', 'synchro', null, null, 'quick_play', 'continuous', 'equip', 'field', 'counter', 'flip', 'toon', 'xyz'];

    thumbImagePath = 'http://images.my-card.in/thumbnail/';

    imagePath = 'http://images.my-card.in/';

    imageExt = '.jpg';

    Card.cardCache = {};

    Card.batchQueryInfo = function(names, callback) {
      var apiUrl, data, i;

      apiUrl = 'http://my-card.in/cards_zh';
      if (typeof names === 'object' && names.length > 0) {
        if (!(function() {
          var _i, _ref, _results;

          _results = [];
          for (i = _i = 0, _ref = names.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push(names[i]);
          }
          return _results;
        })()) {
          names.splice(i, 1);
        }
        data = JSON.stringify({
          "name": {
            "$in": names
          }
        });
        return $.getJSON(apiUrl, {
          q: data
        }, function(res) {
          var info, _i, _len;

          data = {};
          for (_i = 0, _len = res.length; _i < _len; _i++) {
            info = res[_i];
            data[info.name] = info;
          }
          return Card.batchQueryAttr(data, callback);
        });
      }
    };

    Card.batchQueryAttr = function(cards, callback) {
      var apiUrl, data, ids, nameIndex,
        _this = this;

      apiUrl = 'http://my-card.in/cards';
      ids = [];
      nameIndex = {};
      $.each(cards, function(i, card) {
        var id;

        if (!(card._id && card.name)) {
          return true;
        }
        id = parseInt(card._id, 10);
        nameIndex[id] = card.name;
        if (id > 0) {
          return ids.push(id);
        }
      });
      data = JSON.stringify({
        "_id": {
          "$in": ids
        }
      });
      return $.getJSON(apiUrl, {
        l: ids.length,
        q: data
      }, function(res) {
        var card, info, name, _i, _len;

        for (_i = 0, _len = res.length; _i < _len; _i++) {
          info = res[_i];
          name = nameIndex[info._id];
          card = cards[name];
          _this.cardCache[name] = new Card(card, info);
        }
        return callback();
      });
    };

    Card.prototype.id = null;

    Card.prototype.alias = null;

    Card.prototype.name = null;

    Card.prototype.category = null;

    Card.prototype.card_type = null;

    Card.prototype.type = null;

    Card.prototype.attribute = null;

    Card.prototype.level = null;

    Card.prototype.atk = null;

    Card.prototype.def = null;

    Card.prototype.description = null;

    Card.prototype.image = null;

    Card.prototype.thumb = null;

    function Card(card, info) {
      var card_type, category, i;

      i = 0;
      while (info.type) {
        if (info.type & 1) {
          if (card_types[i]) {
            card_type = card_types[i];
          }
          if (categories[i]) {
            category = categories[i];
          }
        }
        info.type >>= 1;
        i++;
      }
      this.id = info._id;
      this.alias = info.alias;
      this.name = card.name;
      this.category = category;
      this.card_type = card_type;
      if (info.race) {
        this.type = (i = 0, (function() {
          var _results;

          _results = [];
          while (!(info.race >> i & 1)) {
            _results.push(i++);
          }
          return _results;
        })(), types[i]);
      }
      if (info.attribute) {
        this.attribute = (i = 0, (function() {
          var _results;

          _results = [];
          while (!(info.attribute >> i & 1)) {
            _results.push(i++);
          }
          return _results;
        })(), _attributes[i]);
      }
      if (info.attribute) {
        this.level = info.level;
      }
      if (info.attribute) {
        this.atk = info.atk;
      }
      if (info.attribute) {
        this.def = info.def;
      }
      this.description = card.desc;
      this.image = imagePath + this.id + imageExt;
      this.thumb = thumbImagePath + this.id + imageExt;
    }

    return Card;

  }).call(this);

  CardDeck = (function() {
    var cardChange, infoNames, panelNames, render, siderDescriptionBox, siderImageBox, siderInfoFields, siderNameBox;

    panelNames = ['主卡组', '副卡组', '额外卡组', '临时卡组'];

    infoNames = [['卡类', 'card_type'], ['种族', 'type'], ['属性', 'attribute'], ['星阶', 'level'], ['攻击', 'atk'], ['守备', 'def']];

    siderNameBox = siderImageBox = siderDescriptionBox = null;

    siderInfoFields = [];

    cardChange = function(img) {
      var field, info, type, _i, _len;

      info = img.data('info');
      siderNameBox.empty().append("<a href=\"#\" target=\"_blank\">" + info.name + "</a>");
      siderImageBox.children('img').attr('src', info.image);
      for (_i = 0, _len = siderInfoFields.length; _i < _len; _i++) {
        field = siderInfoFields[_i];
        type = field.attr('card-title');
        field.html(info[type]);
      }
      return siderDescriptionBox.html(info.description);
    };

    render = function(panel, position) {
      var card, container, contentElement, deckPart, fieldset, i, img, info, legend, main, nameElement, sider, siderInfoBox, siderInfoItemContent, siderInfoItemName, _i, _j, _k, _len, _len1, _ref;

      if (position.left + 828 > document.documentElement.clientWidth) {
        position.left = document.documentElement.clientWidth > 0 ? document.documentElement.clientWidth - 828 : 0;
      }
      container = $('<div></div>').css({
        'position': 'absolute',
        'top': "" + position.top + "px",
        'left': "" + position.left + "px",
        'width': '818px',
        'background': '#FFFFFF',
        'padding': '4px',
        'margin': '4px',
        'bordder': '2px solid #CCCCCC',
        'border-radius': '4px',
        'box-shadow': '0 0 4px #CCCCCC'
      });
      sider = $('<div></div>').css({
        'float': 'right',
        'width': '300px',
        'position': 'relative'
      });
      siderNameBox = $('<div></div>').css({
        'width': '300px',
        'height': 'auto',
        'padding': '8px 0',
        'margin': 0,
        'font-weight': 'bold',
        'text-shadow': '1px 1px 2px #ccc',
        'font-size': '24px',
        'text-align': 'center',
        'background': '#eee',
        'height': '29px'
      });
      siderImageBox = $('<div><img src="http://my-card.in/assets/images/decks/card.jpg" width="130" height="187" /></div>').css({
        'margin': '10px 0 0 10px',
        'height': 'auto',
        'width': 'auto',
        'float': 'left'
      });
      siderInfoBox = $('<div></div>').css({
        'width': '135px',
        'height': '180px',
        'padding': '15px 5px 5px 5px',
        'margin': '7px 0 0 10px',
        'float': 'left'
      });
      siderInfoItemName = $('<div></div>').css({
        'width': '60px',
        'height': '14px',
        'line-height': '14px',
        'padding-bottom': '5px',
        'margin-bottom': '10px',
        'color': '#ffad6e',
        'font-size': '12px',
        'text-shadow': '1px 1px 2px #eee',
        'border-bottom': '1px dashed #ccc',
        'float': 'left'
      });
      siderInfoItemContent = $('<div class="mycard-info-item"></div>').css({
        'width': '75px',
        'height': '14px',
        'padding-bottom': '5px',
        'margin-bottom': '10px',
        'font-size': '12px',
        'color': 'thead_bg#999999',
        'text-shadow': '1px 1px 2px #eee',
        'border-bottom': '1px dashed #ccc',
        'white-space': 'nowrap',
        'text-overflow': 'ellipsis',
        'overflow': 'hidden',
        'float': 'left'
      });
      siderDescriptionBox = $('<div></div>').css({
        'border-bottom': '1px solid #CCCCCC',
        'border-top': '1px solid #CCCCCC',
        'height': '370px',
        'margin': '15px 0 0',
        'padding': '10px',
        'width': '280px',
        'color': '#999999',
        'float': 'left'
      });
      for (_i = 0, _len = infoNames.length; _i < _len; _i++) {
        info = infoNames[_i];
        nameElement = siderInfoItemName.clone().html(info[0]);
        contentElement = siderInfoItemContent.clone().attr('card-title', info[1]);
        siderInfoFields.push(contentElement);
        siderInfoBox.append(nameElement);
        siderInfoBox.append(contentElement);
      }
      sider.append(siderNameBox);
      sider.append(siderImageBox);
      sider.append(siderInfoBox);
      sider.append(siderDescriptionBox);
      main = $('<div></div>').css({
        'float': 'left',
        'position': 'relative'
      });
      for (i = _j = 0; _j < 4; i = ++_j) {
        if (!(panel[i] && panel[i].length)) {
          continue;
        }
        fieldset = $('<fieldset></fieldset>').css({
          'width': '500px',
          'height': '295px',
          'background': '#F9F9F9',
          'border-radius': '6px',
          'color': '#666666',
          'font-size': '12px',
          'margin': '14px 0 0',
          'padding': '5px'
        });
        legend = $("<legend>" + panelNames[i] + "<small>(" + panel[i].length + ")</small></legend>").css({
          'color': '#666666',
          'font-size': '14px',
          'margin-left': '8px'
        });
        legend.children('small').attr('font-size', '10px');
        deckPart = $('<div></div>').attr({
          'margin': '0 -3px 0 -3px'
        });
        _ref = panel[i];
        for (_k = 0, _len1 = _ref.length; _k < _len1; _k++) {
          card = _ref[_k];
          img = $('<img />').attr({
            'width': '44',
            'height': '64',
            'src': card.thumb
          }).css({
            'float': 'left',
            'margin': '0 3px 8px 3px',
            'overflow': 'visible'
          });
          deckPart.append(img);
          img.data('info', card);
          img.bind('mouseenter', function() {
            return cardChange($(this));
          });
        }
        fieldset.append(legend);
        fieldset.append(deckPart);
        main.append(fieldset);
      }
      container.append(main);
      container.append(sider);
      return $('body').append(container);
    };

    CardDeck.prototype.panel = [];

    CardDeck.prototype.data = null;

    CardDeck.prototype.build = function(callback) {
      var deck, name, position, tmp, _i, _j, _len, _len1, _ref;

      if (!this.data.isMatching) {
        return callback();
      }
      position = $(this.data.startNode).position();
      _ref = this.data.deck;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        deck = _ref[_i];
        tmp = [];
        for (_j = 0, _len1 = deck.length; _j < _len1; _j++) {
          name = deck[_j];
          if (Card.cardCache[name]) {
            tmp.push(Card.cardCache[name]);
          }
        }
        this.panel.push(tmp);
      }
      return render(this.panel, position);
    };

    function CardDeck(data) {
      this.build = __bind(this.build, this);      this.data = data;
    }

    return CardDeck;

  })();

  HtmlContent = (function() {
    var block, breakPoint, domTree, eachDom, eachMatch, featureString, matchLastFeature, matchQueue, record, searchBack;

    block = ['div', 'p', 'article', 'section', '#text'];

    featureString = ['####', '====', '$$$$', null];

    domTree = breakPoint = null;

    matchQueue = [];

    eachDom = function(node, callback) {
      var element, item, _i, _len, _ref;

      element = node.content;
      if (!(element && element.childNodes.length)) {
        return callback(false);
      }
      _ref = element.childNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (block.indexOf(item.nodeName.toLowerCase()) === -1) {
          continue;
        }
        domTree.setChild(item, node);
      }
      breakPoint = node;
      return eachMatch(node.firstChild(), function() {
        return callback(true);
      });
    };

    eachMatch = function(node, callback) {
      return matchLastFeature(node, function(_break) {
        if (_break || node.next === null) {
          return callback();
        }
        return eachMatch(node.next, callback);
      });
    };

    matchLastFeature = function(node, callback) {
      var element, feature, text;

      feature = featureString[featureString.length - 2];
      element = node.content;
      text = element.innerText || element.textContent;
      if (text.indexOf(feature) === -1) {
        return searchBack(node, 0, function(_res) {
          return callback(_res);
        });
      }
      if (node.content.childNodes && node.content.childNodes.length) {
        return eachDom(node, function(hasChild) {
          if (hasChild) {
            return callback(false);
          }
        });
      }
    };

    searchBack = function(node, layer, callback) {
      var text;

      layer++;
      node = node.parent;
      if (node.parent === null) {
        return callback(false);
      }
      text = node.content.innerText || node.content.textContent;
      if (text.indexOf(featureString[0]) === -1) {
        if (node === breakPoint) {
          return callback(false);
        } else {
          return searchBack(node, layer, callback);
        }
      } else {
        return record(node, layer, function() {
          return callback(true);
        });
      }
    };

    record = function(node, layer, callback) {
      var htmlNode;

      console.log(node.content);
      htmlNode = new HTMLNode(node.content, layer);
      return htmlNode.parse(function() {
        if (htmlNode.isMatching) {
          matchQueue.push(htmlNode);
        }
        return callback();
      });
    };

    HtmlContent.prototype.parse = function(callback) {
      window.domTree = domTree = new Tree(document.body);
      return eachDom(domTree.root, function(res) {
        return callback(matchQueue);
      });
    };

    function HtmlContent() {
      this.parse = __bind(this.parse, this);      true;
    }

    return HtmlContent;

  })();

  HTMLNode = (function() {
    var block, collectionToArray, featureString, filter, findStart, matchDeck, matchItem, self, setNams,
      _this = this;

    self = null;

    HTMLNode.names = [];

    block = ['div', 'p', 'article', 'section', '#text'];

    featureString = ['####', '====', '$$$$', null];

    HTMLNode.prototype.nodeText = null;

    HTMLNode.prototype.container = null;

    HTMLNode.prototype.startNode = null;

    HTMLNode.prototype.deck = [];

    HTMLNode.prototype.layer = 0;

    HTMLNode.prototype.isMatching = false;

    HTMLNode.prototype.cards = [];

    collectionToArray = function(collection) {
      var arr, i, _i, _len;

      arr = [];
      for (_i = 0, _len = collection.length; _i < _len; _i++) {
        i = collection[_i];
        arr.push(i);
      }
      return arr;
    };

    findStart = function(element, layer, callback) {
      var child, i, item, nodeArray, startNode, text, tmpArray, _i, _j, _k, _l, _len, _len1, _len2, _ref;

      if (layer === 0) {
        return callback(element);
      }
      nodeArray = [element];
      for (i = _i = 0; 0 <= layer ? _i < layer : _i > layer; i = 0 <= layer ? ++_i : --_i) {
        tmpArray = [];
        for (_j = 0, _len = nodeArray.length; _j < _len; _j++) {
          item = nodeArray[_j];
          _ref = item.childNodes;
          for (_k = 0, _len1 = _ref.length; _k < _len1; _k++) {
            child = _ref[_k];
            if (block.indexOf(child.nodeName.toLowerCase()) === -1) {
              continue;
            }
            tmpArray.push(child);
          }
        }
        nodeArray = tmpArray;
      }
      startNode = null;
      console.log(nodeArray);
      for (_l = 0, _len2 = nodeArray.length; _l < _len2; _l++) {
        item = nodeArray[_l];
        text = item.innerText || item.textContent;
        text = text.trim();
        if (text.indexOf('####') > -1) {
          break;
        }
        if (!text) {
          continue;
        }
        if (text.indexOf('##') > -1) {
          if (startNode === null) {
            startNode = item;
          }
        } else {
          startNode = null;
        }
      }
      if (startNode === null) {
        throw 'no match start node';
      }
      if (startNode.nodeName.toLowerCase() === '#text') {
        startNode = $('<m></m>').insertBefore(startNode);
      }
      return callback(startNode);
    };

    filter = function(nodeText, callback) {
      var end, feature, res, start, text, _i, _len;

      res = [];
      start = end = 0;
      for (_i = 0, _len = featureString.length; _i < _len; _i++) {
        feature = featureString[_i];
        if (feature) {
          end = nodeText.indexOf(feature);
        } else {
          end = nodeText.length;
        }
        if (end === -1) {
          throw 'feature not match';
        }
        text = nodeText.substr(start, end - start);
        start = end;
        if (typeof feature === 'string') {
          start += feature.length;
        }
        res.push(text);
      }
      return callback(res);
    };

    matchDeck = function(input, output, callback) {
      var fromFront, item, items, r, tmp, _i, _len;

      if (input.length === 0) {
        return callback(output);
      }
      items = input.shift().split('##');
      fromFront = input.length === 0;
      tmp = [];
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        item = item.trim();
        if (!item) {
          continue;
        }
        r = matchItem(item, fromFront);
        if (fromFront) {
          if (!r) {
            break;
          }
          tmp.push(r);
        } else {
          if (r) {
            tmp.push(r);
          } else {
            tmp = [];
          }
        }
      }
      self.cards = self.cards.concat(tmp);
      output.push(tmp);
      return matchDeck(input, output, callback);
    };

    matchItem = function(item, fromFront) {
      var m, reg;

      reg = fromFront ? /^\[(.*)\]/ : /\[(.*)\]$/;
      m = reg.exec(item.trim());
      if (m) {
        return m[1];
      } else {
        return false;
      }
    };

    setNams = function(names) {
      var name, _i, _len, _results;

      _results = [];
      for (_i = 0, _len = names.length; _i < _len; _i++) {
        name = names[_i];
        if (HTMLNode.names.indexOf(name) === -1) {
          _results.push(HTMLNode.names.push(name));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    HTMLNode.prototype.parse = function(callback) {
      var e, nodeText,
        _this = this;

      nodeText = this.container.innerText || this.container.textContent;
      try {
        return filter(nodeText, function(deck) {
          return findStart(_this.container, _this.layer, function(start) {
            _this.startNode = start;
            window.kaze = _this.startNode;
            return matchDeck(deck, [], function(deck) {
              _this.deck = deck;
              _this.isMatching = true;
              setNams(_this.cards);
              return callback();
            });
          });
        });
      } catch (_error) {
        e = _error;
        console.log(e);
        return callback();
      }
    };

    function HTMLNode(node, layer) {
      this.parse = __bind(this.parse, this);      self = this;
      this.container = node;
      this.layer = layer;
    }

    return HTMLNode;

  }).call(this);

  var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());;

  $ = null;

  Main = (function() {
    var jQueryPath, load;

    jQueryPath = 'http://lib.sinaapp.com/js/jquery/1.9.1/jquery-1.9.1.min.js';

    load = function(path, callback) {
      var scriptElement;

      scriptElement = document.createElement('script');
      scriptElement.type = 'text/javascript';
      scriptElement.src = path;
      scriptElement.onload = function() {
        return callback();
      };
      return document.body.appendChild(scriptElement);
    };

    Main.prototype.start = function() {
      var build, handle, parse;

      $ = jQuery;
      parse = function() {
        var htmlContent;

        htmlContent = new HtmlContent();
        return htmlContent.parse(function(cardQueue) {
          return Card.batchQueryInfo(HTMLNode.names, function() {
            return handle(cardQueue);
          });
        });
      };
      handle = function(cardQueue) {
        if (typeof cardQueue === 'object' && cardQueue.length > 0) {
          return build(cardQueue.shift(), function() {
            return handle(cardQueue);
          });
        }
      };
      build = function(data, callback) {
        var cardDeck;

        cardDeck = new CardDeck(data);
        return cardDeck.build(callback);
      };
      return $(function() {
        return parse();
      });
    };

    function Main() {
      this.start = __bind(this.start, this);
      var _this = this;

      if (typeof jQuery !== 'undefined') {
        this.start();
      } else {
        load(jQueryPath, function() {
          jQuery.noConflict();
          return _this.start();
        });
      }
    }

    return Main;

  })();

  if ((_ref = this.myCardUserJS) == null) {
    this.myCardUserJS = new Main();
  }

  Tree = (function() {
    Tree.prototype.root = null;

    Tree.prototype.setChild = function(content, parentLeaf) {
      var brotherLeaf, newLeaf;

      if (parentLeaf == null) {
        parentLeaf = this.root;
      }
      newLeaf = new Leaf(content);
      if (parentLeaf.children.length) {
        brotherLeaf = parentLeaf.children[parentLeaf.children.length - 1];
        brotherLeaf.next = newLeaf;
        newLeaf.prev = brotherLeaf;
      }
      parentLeaf.children.push(newLeaf);
      newLeaf.parent = parentLeaf;
      return newLeaf;
    };

    function Tree(content) {
      this.setChild = __bind(this.setChild, this);      this.root = new Leaf(content);
    }

    return Tree;

  })();

  Leaf = (function() {
    Leaf.prototype.prev = null;

    Leaf.prototype.next = null;

    Leaf.prototype.parent = null;

    Leaf.prototype.children = [];

    Leaf.prototype.content = null;

    Leaf.prototype.firstChild = function() {
      if (!this.children.length) {
        return false;
      }
      return this.children[0];
    };

    function Leaf(content) {
      this.firstChild = __bind(this.firstChild, this);      this.prev = this.next = this.parent = this.content = null;
      this.children = [];
      this.content = content;
    }

    return Leaf;

  })();

}).call(this);
