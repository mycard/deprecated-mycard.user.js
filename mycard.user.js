// Generated by CoffeeScript 1.6.2
(function() {
  var $, Batch, Card, CardDeck, HtmlContent, Main, cardCache, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Batch = function(names, callback) {
    var apiUrl, tile,
      _this = this;

    apiUrl = 'http://my-card.in/cards_zh';
    tile = function(array, result, _callback) {
      var item;

      if (!array.length) {
        return _callback(result);
      }
      item = array.shift();
      if (typeof item === 'string') {
        if (item) {
          result.push(item);
        }
        return tile(array, result, _callback);
      } else {
        return tile(item, result, function(res) {
          return tile(array, res, _callback);
        });
      }
    };
    if (!names.length) {
      return;
    }
    return tile(names, [], function(names) {
      var data, i;

      if (!(function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = names.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(names[i]);
        }
        return _results;
      })()) {
        names.splice(i, 1);
      }
      data = JSON.stringify({
        "name": {
          "$in": names
        }
      });
      return $.getJSON(apiUrl, {
        q: data
      }, function(res) {
        var info, _i, _len;

        for (_i = 0, _len = res.length; _i < _len; _i++) {
          info = res[_i];
          cardCache[info.name] = info;
        }
        console.log(cardCache);
        return callback();
      });
    });
  };

  Card = (function() {
    /*
    	# API format
    	# name:
    	#	$in : nameArray
    */
    Card.prototype.name = null;

    Card.prototype.info = null;

    Card.prototype.getInfo = function(callback) {
      return this.init(callback);
    };

    Card.prototype.init = function(callback) {
      return callback(this.name);
    };

    function Card(name) {
      this.init = __bind(this.init, this);
      this.getInfo = __bind(this.getInfo, this);      this.name = name;
    }

    return Card;

  })();

  CardDeck = (function() {
    var bulidCallback, cardPart, render, tile,
      _this = this;

    cardPart = 4;

    bulidCallback = null;

    tile = function(array, result, callback) {
      var item;

      if (!array.length) {
        return callback(result);
      }
      item = array.shift();
      if (typeof item === 'string') {
        if (item) {
          result.push(item);
        }
        return tile(array, result, callback);
      } else {
        return tile(item, result, function(res) {
          return tile(array, res, callback);
        });
      }
    };

    render = function() {
      return console.log(self.cards);
    };

    CardDeck.prototype.names = [];

    CardDeck.prototype.cards = [];

    CardDeck.prototype.build = function(callback) {
      bulidCallback = callback;
      return console.log(this.names);
    };

    function CardDeck(data) {
      this.build = __bind(this.build, this);      this.names = data;
    }

    return CardDeck;

  }).call(this);

  HtmlContent = (function() {
    var content, contentArray, contentArrayLength, drag, dragOnceOver, filter, parseCallback, partDelimiterRules, queue, refine;

    partDelimiterRules = [null, '####', '====', '$$$$'];

    content = '';

    contentArray = [];

    contentArrayLength = 0;

    queue = [];

    parseCallback = null;

    /*
    	# 内容抓取
    	#
    	# 按 #*4分割(从开始到#*4)
    	# 找到第一个##行
    	# 判断是否为[*]
    	# 同理====以及剩余部分(到$$$$前）
    	# 分析下一个part的开头是否为[*]
    */


    drag = function(startLine) {
      var handles, index, recursion, result, rule, text;

      result = [];
      text = contentArray[startLine];
      rule = partDelimiterRules;
      rule[rule.length - 1] = null;
      index = 0;
      handles = [];
      recursion = function() {
        if (index < rule.length - 1) {
          return filter(text, rule[index], rule[index + 1], false, function(_res) {
            result.push(_res);
            index++;
            return recursion();
          });
        } else {
          return filter(contentArray[startLine + 1], null, null, true, function(_res) {
            result.push(_res);
            return dragOnceOver(startLine, result);
          });
        }
      };
      return recursion();
    };

    filter = function(text, startDelimiter, endDelimiter, fromFront, callback) {
      var data, end, line, matchLine, result, start, _i, _j, _len, _len1, _r;

      matchLine = function(line, fromFront) {
        var m, reg;

        reg = fromFront ? /^\[(.*)\]/ : /\[(.*)\]$/;
        m = reg.exec(line.trim());
        if (m) {
          return m[1];
        } else {
          return false;
        }
      };
      if (typeof text === 'string') {
        text = text.trim();
      }
      if (!text) {
        return callback('');
      }
      start = startDelimiter ? text.indexOf(startDelimiter) + startDelimiter.length : 0;
      end = endDelimiter ? text.indexOf(endDelimiter) : text.length;
      text = text.substr(start, end - start);
      if (!text) {
        return callback('');
      }
      data = text.split('##');
      result = [];
      if (fromFront) {
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          line = data[_i];
          line = line.trim();
          if (!line) {
            continue;
          }
          _r = matchLine(line, true);
          if (!_r) {
            break;
          }
          result.push(_r);
        }
        return callback(result);
      }
      for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
        line = data[_j];
        line = line.trim();
        if (!line) {
          continue;
        }
        _r = matchLine(line);
        if (_r) {
          result.push(_r);
        } else {
          result = [];
        }
      }
      return callback(result);
    };

    refine = function() {
      return parseCallback(queue);
    };

    dragOnceOver = function(startLine, result) {
      startLine += 1;
      queue.push(result);
      if (startLine < contentArrayLength) {
        return drag(startLine);
      }
      return refine();
    };

    HtmlContent.prototype.parse = function(callback) {
      if (contentArrayLength === 0) {
        return callback(false);
      }
      parseCallback = callback;
      /*
      		# drag -> dragOnceOver -> drag -> ... -> refine -> callback
      */

      return drag(0);
    };

    function HtmlContent() {
      this.parse = __bind(this.parse, this);      content = document.body.innerText || document.body.textContent;
      content = content.replace(/[\r\n]/g, '');
      contentArray = content.split(partDelimiterRules[partDelimiterRules.length - 1]);
      contentArrayLength = contentArray.length;
    }

    return HtmlContent;

  })();

  $ = null;

  cardCache = {};

  Main = (function() {
    var jQueryPath, load;

    jQueryPath = 'http://lib.sinaapp.com/js/jquery/1.9.1/jquery-1.9.1.min.js';

    load = function(path, callback) {
      var scriptElement;

      scriptElement = document.createElement('script');
      scriptElement.type = 'text/javascript';
      scriptElement.src = path;
      scriptElement.onload = function() {
        return callback();
      };
      return document.body.appendChild(scriptElement);
    };

    Main.prototype.start = function() {
      var build, handle, parse;

      $ = jQuery;
      parse = function() {
        var htmlContent;

        htmlContent = new HtmlContent();
        return htmlContent.parse(function(cardQueue) {
          console.log(cardQueue);
          return;
          return Batch(cardQueue, function() {
            return handle(cardQueue);
          });
        });
      };
      handle = function(cardQueue) {
        if (typeof cardQueue === 'object' && cardQueue.length > 0) {
          return build(cardQueue.shift(), function() {
            return handle(cardQueue);
          });
        }
      };
      build = function(data, callback) {
        var cardDeck;

        cardDeck = new CardDeck(data);
        return cardDeck.build(callback);
      };
      return $(function() {
        return parse();
      });
    };

    function Main() {
      this.start = __bind(this.start, this);
      var _this = this;

      if (typeof jQuery !== 'undefined') {
        this.start();
      } else {
        load(jQueryPath, function() {
          jQuery.noConflict();
          return _this.start();
        });
      }
    }

    return Main;

  })();

  if ((_ref = this.myCardUserJS) == null) {
    this.myCardUserJS = new Main();
  }

}).call(this);
